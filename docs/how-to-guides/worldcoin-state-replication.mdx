# Setting Up Cross-Chain Identity State Replication for World ID

In this guide, we'll set up the cross-chain identity state replication for World ID. It enables the usage of World ID zero-knowledge proofs on any chain supported by Rarimo.

## Pre-Requisites

Before getting started, please contact us in [discord](https://discordapp.com/invite/rarimoprotocol) to ensure that the issuer is added to the allowlist and that a lightweight identity manager contract is already deployed to the destination chain;

Other pre-requisites:
- [Postgres DB 13+](https://www.postgresql.org/download/) instance for the relayer service;
- [Docker](https://docs.docker.com/engine/install/) and [docker-compose](https://docs.docker.com/compose/install/) (optional)

## Setting Up Relayer

The Relayer service is responsible for replicating the World ID state on demand. It exposes a REST endpoint for the DApps that performs the state replication to the target chain.

### Build

You can pull the pre-build docker image:

```sh
docker pull ghcr.io/rarimo/worldcoin-relayer-svc:v0.1.0
```

Or clone the  [repository](https://github.com/rarimo/worldcoin-relayer-svc) and build it from the source:

```sh
git clone git@github.com:rarimo/worldcoin-relayer-svc.git

CGO_ENABLED=1 go build .
```

## Configuration

Service configuration consists of two parts:

### Environment

```shell
export KV_VIPER_FILE=/config.yaml
```

### Config file

```yaml
log:
  disable_sentry: true
  level: debug

# The port to run on
listener:
  addr: :8000

# PostgreSQL DB connect
db:
  url: "postgres://postgres:postgres@localhost:5432/postgres?sslmode=disable"

# Rarimo core RPCs
core:
  addr: tcp://validator:26657

cosmos:
  addr: validator:9090

evm:
  chains:
    - name: "Avalanche"
      ## Address of the modified state contract on target chain
      contract_address: ""
      ## Private key HEX (without leading 0x) that will pay the tx fee
      submitter_private_key: ""
      ##  RPC address. Example https://mainnet.infura.io/v3/11111
      rpc:
      ## Target chain id
      chain_id: 1

relay:
  # Flag the indicates should service iterate over all existing transfer operation and fill the database
  catchup_disabled: true
```

----

## Run

### Binary Built From Source

```sh
# apply DB migrations and run the service
./relayer-svc migrate up && ./relayer-svc run all
```

### Using `docker-compose`

1. Put the config at `./config.yaml`
1. Create `./docker-compose.yml`:
  ```yaml
  version: "3.7"

  services:
    relayer-db:
      image: postgres:13
      restart: unless-stopped
      environment:
        - POSTGRES_USER=relayer
        - POSTGRES_PASSWORD=relayer
        - POSTGRES_DB=relayer
        - PGDATA=/pgdata
      volumes:
        - relayer-data:/pgdata

    relayer:
      image: path/to/image:hash
      restart: on-failure
      ports:
        - "8000:8000"
      depends_on:
        - relayer-db
      volumes:
        - ./config/relayer.yaml:/config.yaml
      environment:
        - KV_VIPER_FILE=/config.yaml
      entrypoint: sh -c "relayer-svc migrate up && relayer-svc run all"
  volumes:
    relayer-data:
  ```
1. Run the service:
  ```sh
  docker-compose up
  ```

## Using Service

Execute the POST `/integrations/relayer/state/relay` request with the following body to fetch state publishing:
```json
{
    "chain": "Avalanche",
    "hash": "0x1851e2c82ba946e9ba978a40571e4c1294a282d24912ff26496106445299f099",
    "waitConfirm": true
}
```
`"waitConfirm": true` - indicates if request should wait until transaction will be included into the block. Default - `false`.

The response will be:

- `200` – successful relay, tx hash in the response body;
- `404` – the state wasn't ingested by Rarimo Core yet; wait a little and repeat the request;
- `400` – the state has been relayed before;  <!-- TODO: fix me -->
