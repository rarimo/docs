---
title: World ID Replication Usage
---

<!-- todo: change Polygon to another chain (e.g, Avalanche), remove Polygon mentions from the full doc -->

# Tutorial: Using World ID zero-knowledge proofs in Polygon DApp

In this tutorial we are going to build a dApp, that will ask the user to provide a proof of personhood, using the World App.
So, having the contracts deployed on Ethereum, we can replicate the state to another chain, e.g. Polygon, so that the proofs can be used in Polygon dApp.

## DApp creation

Our simple DApp will consist of 2 parts:
- front-end, that contains the QR-code (can be scanned with the World App), which asks for the proof of personhood;
- verifier smart contract;

### Smart Contracts

Let's start from writing a verifier contract, that will verify user's proof of personhood.
We should also have the `IdentityManager` contract deployed on destination chain, but that's the job of the Rarimo team.

#### `Verifier`

`Verifier` has two hooks, namely `_beforeProofSubmit(...)` and `_afterProofSubmit(...)`, which are called before and after proof verification respectively.
You can override them with business logic you need.
Contract also uses [Initializable from OpenZeppelin](link) and [SemaphoreVerifier from World ID](link), where the second contract is responsible for actual ZKP verification.

So here is the template for our `Verifier` contract:

```solidity
pragma solidity 0.8.20;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

import "./vendor/worldcoin/world-id-contracts/interfaces/ISemaphoreVerifier.sol";

import "./interfaces/IIdentityManager.sol";
import "./interfaces/IVerifier.sol";

contract Verifier is IVerifier, Initializable {
    address public semaphoreVerifier;
    address public identityManager;

    function __Verifier_init(
        address semaphoreVerifier_,
        address identityManager_
    ) external initializer {
        /* ... */
    }

    function verifyProof(
        uint256 root_,
        uint256 signalHash_,
        uint256 nullifierHash_,
        uint256 externalNullifierHash_,
        uint256[8] calldata proof_
    ) public virtual override {
        /* ... */
    }

    function _beforeProofValidation() internal virtual {}

    function _afterProofValidation() internal virtual {}
}
```

Functions should have the following functionality:
- `__Verifier_init(...)` – sets the `semaphoreVerifier` and `identityManager` variables with provided ones;
- `verifyProof(...)` – checks, whether the root is expired, calls the proof verification function (IdentityManager functionality) and executes both hooks, before and after proof verification respectively;
- `_beforeProofValidation(...)` – hook, that should be executed before proof verification.
Any logic you want can be executed, usually some security checks are performed;
- `_afterProofValidation(...)` – hook, that should be executed after proof verification.
As previous hook, contains any logic you want.

The filled version of the contract should look like this:

```solidity
pragma solidity 0.8.20;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

import "./vendor/worldcoin/world-id-contracts/interfaces/ISemaphoreVerifier.sol";

import "./interfaces/IIdentityManager.sol";
import "./interfaces/IVerifier.sol";

contract Verifier is IVerifier, Initializable {
    address public semaphoreVerifier;
    address public identityManager;

    function __Verifier_init(
        address semaphoreVerifier_,
        address identityManager_
    ) external initializer {
        semaphoreVerifier = semaphoreVerifier_;
        identityManager = identityManager_;
    }

    function verifyProof(
        uint256 root_,
        uint256 signalHash_,
        uint256 nullifierHash_,
        uint256 externalNullifierHash_,
        uint256[8] calldata proof_
    ) public virtual override {
        require(
            !IIdentityManager(identityManager).isExpiredRoot(root_),
            "Verifier: root is expired"
        );

        _beforeProofValidation();

        ISemaphoreVerifier(semaphoreVerifier).verifyProof(
            proof_,
            [root_, nullifierHash_, signalHash_, externalNullifierHash_]
        );

        _afterProofValidation();
    }

    function _beforeProofValidation() internal virtual {}

    function _afterProofValidation() internal virtual {}
}
```

We have not filled hooks, their logic is up to you.

For the full implementation, see [Verifier.sol](link) at the GitHub.

### Front-end 

The flow of our dApp will be as following:

Firstly, the user will be asked to connect with his Metamask wallet.
After connecting the wallet, user can go through the verification process
![Connect the wallet](/img/world-id-verify.png)

After clicking on the button, QR code appears, that can be scanned with the World App
![Connect the wallet](/img/world-id-qr-code.png)

Scanning the QR will ask the user (in the World App) to generate the proof.
After successful proof generation, it should be submitted on-chain with all necessary information
![Connect the wallet](/img/world-id-proof-generated.png)

Finally, after proof is submitted, user can review the correctness, using the transaction hash
![Connect the wallet](/img/world-id-tx-hash.png)

To create the front-end we will use the following stack of technologies:
- [React](https://github.com/facebook/react/releases)
- [Vite.js](https://github.com/vitejs/vite/releases)
- [Distributed Lab web-kit](https://github.com/distributed-lab/web-kit/tree/main)
- [crypto](https://github.com/iden3/js-crypto), [jwz](https://github.com/iden3/js-jwz), [core](https://github.com/iden3/js-iden3-core), [jsonld-merklization](https://github.com/iden3/js-jsonld-merklization), [merkletree](https://github.com/iden3/js-merkletree) libraries from iden3
- [Yarn](https://github.com/yarnpkg) as a package manager
- [World ID kit](https://github.com/worldcoin/idkit-js)

We will use World ID Kit, that provides rich and easy to use functionality that will handle proof processing, such as `IDKitWidget`.
We should provide the following information to this component:

- `signal` – the signal to be included in the zero-knowledge proof.
Typically used for on-chain actions;
- `action` – Identifier for the action the user is performing;
- `onSuccess` – Function to trigger when verification is successful and the modal is closed.
Should receive a single parameter of type `ISuccessResult` which contains the proof details;
- `app_id` – unique identifier for the app verifying the action.
This should be the App ID obtained from the [Developer Portal](https://developer.worldcoin.org/);

Here is the part of landing page, which you can fill and use at your page:

```ts
          <div className='auth-proof__card'>
            <div className='auth-proof__card-header'>
              <div className='auth-proof__card-qr-wrp'>
                {provider?.isConnected ? (
                  <IDKitWidget
                    signal={provider.address} // the signal we will include is user's metamask address
                    action='your-action'
                    onSuccess={handleZkProofGen} // handle function, that redirect the user in case of a valid proof in our case
                    app_id={your-app-id}
                  >
                    {({ open }) => (
                      <AppButton
                        className='auth-proof__card-btn'
                        text={'verify with world id'}
                        onClick={open}
                      />
                    )}
                  </IDKitWidget>
                ) : (
                  <>
                    <AppButton
                      className='auth-proof__connect-btn'
                      text={'CONNECT METAMASK'}
                      onClick={connectProvider}
                    >
                      {`Connect Wallet`}
                    </AppButton>
                  </>
                )}
              </div>
            </div>
            <div className='auth-proof__card-body'>
              <div className='auth-proof__card-title'>
                {`Scan the QR code with your Worldcoin wallet to generate proof`}
              </div>
            </div>
          </div>
```

Let's add a few parts, so it will display the first two steps of our flow.
The final code may look like this:

```ts
import './styles.scss'

import { config } from '@config'
import { PROVIDERS } from '@distributedlab/w3p'
import { IDKitWidget } from '@worldcoin/idkit'
import { FC, HTMLAttributes, useCallback } from 'react'

import { AppButton, Loader } from '@/common'
import { useWeb3Context, useZkpContext } from '@/contexts'
import { ErrorHandler } from '@/helpers'

type Props = HTMLAttributes<HTMLDivElement>

const AuthProof: FC<Props> = () => {
  const { isPending, handleZkProofGen } = useZkpContext()

  const { provider, init } = useWeb3Context()

  const connectProvider = useCallback(async () => {
    try {
      await init(PROVIDERS.Metamask)
    } catch (error) {
      ErrorHandler.process(error)
    }
  }, [init])

  return (
    <div className='auth-proof'>
      {isPending ? (
        <>
          <div className='auth-proof__header'>
            <h2 className='auth-proof__header-title'>{`Check Transition states`}</h2>
            <span className='auth-proof__header-subtitle'>{`Please wait...`}</span>
          </div>

          <div className='auth-proof__loader-wrp'>
            <Loader className='auth-proof__loader' />
          </div>
        </>
      ) : (
        <>
          <div className='auth-proof__header'>
            <h2 className='auth-proof__header-title'>{`Generate Proof`}</h2>
            <span className='auth-proof__header-subtitle'>{`Scan QR Code`}</span>
          </div>

          <div className='auth-proof__card'>
            <div className='auth-proof__card-header'>
              <div className='auth-proof__card-qr-wrp'>
                {provider?.isConnected ? (
                  <IDKitWidget
                    signal={provider.address}
                    action='your-action'
                    onSuccess={handleZkProofGen}
                    app_id={config.WORLDCOIN_APP_ID}
                  >
                    {({ open }) => (
                      <AppButton
                        className='auth-proof__card-btn'
                        text={'verify with world id'}
                        onClick={open}
                      />
                    )}
                  </IDKitWidget>
                ) : (
                  <>
                    <AppButton
                      className='auth-proof__connect-btn'
                      text={'CONNECT METAMASK'}
                      onClick={connectProvider}
                    >
                      {`Connect Wallet`}
                    </AppButton>
                  </>
                )}
              </div>
            </div>
            <div className='auth-proof__card-body'>
              <div className='auth-proof__card-title'>
                {`Scan the QR code with your Worldcoin wallet to generate proof`}
              </div>
            </div>
          </div>
        </>
      )}
    </div>
  )
}

export default AuthProof
```

This code will be used to generate the proof in user's World App.
After generating the proof, we want to submit it on-chain.
To do that, transaction body should be filled with:
- issuer state root, for which the proof is created;
- hash of the user's address, which we provided as a signal;
- nullifier hash, which is stored in ZKP we generated;
- external nullifier hash, which is the packed hash of `app_id` and `action`;
- unpacked proof;

Let's define the function, that does that:

```ts
const submitZkp = useCallback(async () => {
    setIsSubmitting(true)

    try {
      if (!zkProof) throw new TypeError('ZKP is not defined')

      if (!provider?.address) throw new TypeError('Provider is not defined')

      const hashToField = (value: string) => {
      }

      const externalNullifierHash = hashToField(
        utils.solidityPack(
          ['uint256', 'string'],
          [
            hashToField(
              utils.solidityPack(['string'], [config.WORLDCOIN_APP_ID]),
            ).toHexString(),
            'your-action',
          ],
        ),
      )

      const unpackedProof = utils.defaultAbiCoder.decode(
        ['uint256[8]'],
        zkProof.proof,
      )[0]

      const txBody = getProveIdentityTxBody(
        zkProof.merkle_root,
        hashToField(provider.address).toHexString(),
        zkProof.nullifier_hash,
        externalNullifierHash.toHexString(),
        unpackedProof.map((el: unknown) => BigNumber.from(el).toHexString()),
      )

      const tx = await provider?.signAndSendTx?.({
        to: config?.[
          `QUERY_VERIFIER_CONTRACT_ADDRESS_${selectedChainToPublish}`
        ],
        ...txBody,
      })

      verificationSuccessTx.set((tx as EthTransactionResponse).transactionHash)

      navigate(RoutesPaths.authSuccess)
    } catch (error) {
      ErrorHandler.process(error)
    }

    setIsSubmitting(false)
  }, [
    zkProof,
    getProveIdentityTxBody,
    navigate,
    provider,
    selectedChainToPublish,
    verificationSuccessTx,
  ])
```

Finally, after transaction has been added to the block, we will show its hash to the user using the following code:

```ts
    <div className='auth-success'>
      <div className='auth-success__header'>
        <div className='auth-success__header-icon-wrp'>
          <Icon className='auth-success__header-icon' name={ICON_NAMES.check} />
        </div>
        <h2 className='auth-success__header-title'>{`Proof Submitted`}</h2>
      </div>

      <div className='auth-success__card'>
        <span className='auth-success__card-title'>{`Check transaction`}</span>

        <a
          className='auth-success__copy-field-wrp'
          href={provider?.getTxUrl?.(
            config.SUPPORTED_CHAINS_DETAILS[config.DEFAULT_CHAIN],
            verificationSuccessTx.get,
          )}
          target='_blank'
          rel='noreferrer'
        >
          <span className='auth-success__copy-field'>
            {abbrCenter(verificationSuccessTx.get, 10)}
            <Icon
              className='auth-success__copy-field-icon'
              name={ICON_NAMES.externalLink}
            />
          </span>
        </a>
      </div>
        <AppButton
        className='auth-success__return-btn'
        routePath={'/'}
        text={`RETURN HOME`}
        size={`large`}
      />
    </div>
```

At this point user has passed the verification and you can be sure, that it's the real humant and not a bot and provide him the full access to your dApp.

For the full front-end implementation, see [GitHub](https://github.com/rarimo/web-client-worldcoin-id/tree/main).