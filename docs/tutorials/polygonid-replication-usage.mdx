---
title: Polygon ID Replication Usage
---

# Polygon ID x Rarimo Collaboration
<!-- it's just a very early version of the document. It may changed unpredictably -->

Rarimo has an integration with Polygon ID, that allows replication of the state to other chains.
For example, the issuer, whose state exists on Polygon, can be replicated to another chain, e.g. Ethereum, so that the claims he issued can be proven in Ethereum DApp.

## Polygon ID State Replication flow

Polygon ID was one of the first projects that introduced the framework to work with identity.
All artifacts are stored on Polygon network, which may be uncomfortable to use, when your DApp is deployed on other chains.
Having the Issuer, that works with Polygon and DApp on Ethereum creates some problems.

Luckily for us, Rarimo has a solution that solves these problems.
This tutorials is intended to show the creation of DApp, that will use Rarimo x Polygon State Replication to interact with claims, that were issued on Polygon and replicated to Ethereum.
Additionally the contract will mint a Soulbound Token indicating that this address has passed the verification.

## DApp creation

Our simple DApp will consist of 2 parts:
- front-end, that contains the QR-code (that can be scanned with Polygon ID Wallet), which asks for the proof, e.g. that the user was born before `2000/01/01`;
- smart contracts, concretely the verifier and SBT contracts;

After providing the valid proof, user will be rewarded with the soul-bound token.

### Smart Contracts

Let's start from writing a simple set of contracts, that will require the user to provide a proof (credentials), that he was born before the `2000/01/01`.
To do that we need to write:
- `SBT` contract, that will mint the soul-bound token to the user;
- `Verifier` contract, that will verify the proof and call the SBT contract to mint the token;

It is desired to make them upgradeable, but we will try to make them as simple as possible for understanding.

#### `VerifiedSBT`

Let's start from writing our SBT contract.
Our goal, as stated before - to mint an SBT on successful verification.
Here is the template of the contract, that we will fill (we will use [OpenZeppelin](https://github.com/OpenZeppelin/openzeppelin-contracts/tree/v4.4.0/contracts/token/ERC721/extensions) ERC721 contracts, don't forget to clone them):

```solidity
pragma solidity 0.8.16;

import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";

contract VerifiedSBT is ERC721Enumerable {

    address public verifier;
    uint256 public nextTokenId;
    string public tokensURI;

    
    constructor() ERC721("Name", "Symbol") {}

    modifier onlyVerifier() {}

    function getNextTokenId() view external returns (uint256) {}

    function setVerifier(address newVerifier_) external {}

    function setTokensURI(string calldata newTokensURI_) external {}

    function mint(address recipientAddr_) external onlyVerifier() {}

    function _beforeTokenTransfer(address from,address to, uint256 tokenId) internal override {}

}
```

- `verifier` is the address of our verifier contract;
- `nextTokenId` nonce, that should be increment with every new minted SBT, so all SBTs have different id; 
- `tokensURI` token URI as in NFTs;
- `onlyVerifier()` - modifier, that makes mint function callable only by the verifier contract;
- `getNextTokenId()` - getter function, that returns current `nextTokenId`;
- `setVerifier(address)` - function, that sets the verifier.
We should call it manually after deployment, cause verifier has `sbtContract` address variable too; 
- `setTokensURI(string)` - sets the tokensURI.
Can be removed, if tokensURI will be set in the constructor;
- `mint(address)` - main function, that mints the token (ERC721 has `_mint(address, uint256)` ); 
- `_beforeTokenTransfer(...)` - hook, that should be modified, so the tokens can't be transferred;

So, now we can fill all the functions and we are ready to go.
Try to fill it by yourself, but if you can't, here is the full contract:

```solidity
pragma solidity 0.8.16;

import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";

contract VerifiedSBT is ERC721Enumerable {
    address public verifier;
    uint256 public nextTokenId;
    string public tokensURI;

    constructor() ERC721("Name", "Symbol") {}

    modifier onlyVerifier() {
        require(msg.sender == verifier, "VerifiedSBT: only verifier can call this function");
        _;
    }

    // it is better to make set functions callable only be the owner of the contract;
    // you can add it by yourself, but for our studying purposes it is not needed

    function setVerifier(address newVerifier_) external {
        verifier = verifier_;
    }

    function getNextTokenId() view external returns (uint256){
        return nextTokenId;
    }

    function setTokensURI(string calldata newTokensURI_) external {
        tokensURI = tokensURI_;
    }

    function mint(address recipientAddr_) external override onlyVerifier {
        _mint(recipientAddr_, nextTokenId++);
    }

    function _beforeTokenTransfer(
        address from_,
        address to_,
        uint256 firstTokenId_,
        uint256 batchSize_
    ) internal override {
        require(
            from_ == address(0) || to_ == address(0),
            "VerifiedSBT: token transfers are not allowed"
        );

        super._beforeTokenTransfer(from_, to_, firstTokenId_, batchSize_);
    }
}
```

Great! Now we need to write a `QueryVerifier` and we are ready to use Polygon ID State Replication.
You can modify the hook, so the token won't be burnable, by removing the `to_ == address(0)` requirement.


#### `QueryVerifier`

Verifier contract is responsible for verifying the proof.
We don't need to implement the `verify(...)` function, because our contract inherits iden3 `ZKPVerifier`.
It has two hooks - `_beforeProofSubmit(...)` and `_afterProofSubmit(...)`, which are called before and after proof verification respectively.
We will override them and add our SBT-minting logic to them.
We should specify at least one request id for our proofs (in our case â€“ `AGE_VERIFY_REQUEST_ID`).
We should also create the `IVerifiedSBT` interface, which contains all functions we created before.
So here is the template for our contract:

```solidity
pragma solidity 0.8.16;

import "@iden3/contracts/verifiers/ZKPVerifier.sol";
import "@iden3/contracts/lib/GenesisUtils.sol";
import "@iden3/contracts/interfaces/ICircuitValidator.sol";

import "./interfaces/IVerifiedSBT.sol";

contract QueryVerifier is ZKPVerifier {
    //the request id, which will be used in the proofs
    uint256 public constant AGE_VERIFY_REQUEST_ID = 1;

    // our sbtContract that we created before
    IVerifiedSBT public sbtContract;

    // mapping of addresses to identities
    mapping(address => uint256) public addressToUserId;

    mapping (uint256 => address) public userIdToAddress;
    
    function setSBTContract(address sbtContract_) external {}

    function isUserVerified(uint256 userId_) public view returns (bool) {}

    function _beforeProofSubmit(
        uint64,
        uint256[] memory inputs_,
        ICircuitValidator
    ) internal override {}

    function _afterProofSubmit(
        uint64,
        uint256[] memory inputs_,
        ICircuitValidator
    ) internal override {}

}
```

- `AGE_VERIFY_REQUEST_ID` - the request id, that is used to identify which proof is provided by the user;
- `sbtContract` - SBT contract that we created before.
Verifier will call it to mint an SBT to the user after the verification;
- `addressToUserId` - mapping of addresses to users identities;
- `userIdToAddress` - mapping of users identities to addresses;
- `setSBTContract(address)` - function, that sets the SBT contract.
As being said, it is better to add `onlyOwner` modifier to it;
- `isUserVerified(uint256)` - auxiliary function, that returns whether the provided identity has already been verified;
- `_beforeProofSubmit(...)` - the first of two hooks, that is called before the proof verification.
It will check, whether the identity has not been verified yet and whether the address has previously submitted the proof;
- `_afterProofSubmit(...)` - the second hook, that is called after the successful verification of the proof.
It will add the user's identity and address that submitted the proof to mappings and mint the proof for the user;

We want to "bind" addresses to user identities and vice versa, so that one address can't prove multiple identities and one identity can't be proven by two or more addresses, that's why we define two mappings.

The filled version of the contract is shown below:

```solidity
pragma solidity 0.8.16;

import "@iden3/contracts/verifiers/ZKPVerifier.sol";
import "@iden3/contracts/lib/GenesisUtils.sol";
import "@iden3/contracts/interfaces/ICircuitValidator.sol";

import "./interfaces/IQueryVerifier.sol";
import "./interfaces/IVerifiedSBT.sol";

contract QueryVerifier is ZKPVerifier {
    uint256 public constant AGE_VERIFY_REQUEST_ID = 1;

    IVerifiedSBT public sbtContract;

    mapping(address => uint256) public addressToUserId;

    mapping (uint256 => address) public userIdToAddress;

    function isUserVerified(uint256 userId_) public view returns (bool) {
        return userIdToAddress[userId_] != address(0);
    }

    function _beforeProofSubmit(
        uint64,
        uint256[] memory inputs_,
        ICircuitValidator
    ) internal override {
        require(
            // what is inside inputs_ depends on the credentials scheme
            !isUserVerified(inputs_[1]),
            "Identity with this identifier has already been verified"
        );
        require(
            addressToUserId[msg.sender] == 0,
            "Current address has already been used to verify another identity"
        );
    }

    function _afterProofSubmit(
        uint64,
        uint256[] memory inputs_,
        ICircuitValidator
    ) internal override {
        uint256 tokenId_ = sbtContract.nextTokenId();
        uint256 userId_ = inputs_[1];

        userIdToAddress[userId_] = msg.sender;
        addressToUserId[msg.sender] = userId_;

        sbtContract.mint(msg.sender);

    }
}
```

The full code can be found [here](https://github.com/rarimo/polygonid-integration-contracts/blob/master/contracts/QueryVerifier.sol).
Note, that created above contracts are "education-only", and are slightly different from our production implementation.

### Front-end

The Front-end requests the QR-code from the back-end service and shows it on the page.
User can scan this QR-code with his Polygon ID Wallet and generate a proof, if he possess the valid credentials.
After that, user can use the relayer to transit the state from Polygon to Ethereum.

Let's start by writing the function that creates the request to the back-end service.
The service will return the QR-code in JSON format, which we will display.
We should specify the following information in the request:
- `id` â€“ identifier stored on the wallet SDK;
- `thid` â€“ id of the message thread;
- `from` â€“  from where the authentication request comes, i.e. the identifier of the identity from which a Verifier requests proof (`VITE_REQUEST_BUILD_SENDER` in environment files);
- `typ` â€“ iden3comm Media Type, i.e. file format for the type field. (For example, JSON)
- `type` â€“ type of iden3comm Protocol Message; type of request; it could be an auth request, proof request, or a credential offer
- `body`, that consists of: 
    - `reason` â€“ reason of authentication (it could be age verification or simply a test flow)
    - `message` â€“ message to be signed; can be left blank
    - `callbackUrl` â€“ URI to which requested information is sent and response is received
    - `scope` â€“ information related to the proof request and the requirements to be fulfilled by the proof generated and shared from mobile.
    It is in the form of an array of proofs that the SDK generates.

You can provide other information as well, for more explanation, check [this](https://devs.polygonid.com/docs/wallet/wallet-sdk/polygonid-sdk/iden3comm/auth-requests/).

The code may look like this:
```ts
import { config } from '@config'
import { v4 as uuidv4 } from 'uuid'

import { api } from '@/api'
import {
  CLAIM_TYPES_MAP_OFF_CHAIN,
  CLAIM_TYPES_MAP_ON_CHAIN,
} from '@/contexts/ZkpContext/consts'
import { ClaimTypes } from '@/contexts/ZkpContext/enums'

export const createRequestOnChain = (
  reason: string,
  message: string,
  sender: string,
  callbackUrl: string,
) => {
  const uuid = uuidv4()

  return {
    id: uuid,
    thid: uuid,
    from: sender,
    typ: 'application/iden3comm-plain-json',
    type: 'https://iden3-communication.io/authorization/1.0/request',
    body: {
      reason: reason,
      // message: message,
      callbackUrl: callbackUrl,
      scope: [],
    },
  }
}

export const buildRequestOnChain = async (
  callbackBaseUrl: string,
  claimType: ClaimTypes, // we have defined this enum in another file. it's equal to a string 'KYCAgeCredential' in this demo.
) => {
  const { data } = await api.get<{
    verification_id: string
    jwt: string
  }>('/integrations/verify-proxy/v1/public/verify/request')

  const request = createRequestOnChain(
    'SBT airdrop',
    '', 
    config.REQUEST_BUILD_SENDER,
    `${callbackBaseUrl}/integrations/verify-proxy/v1/public/verify/callback/${data.verification_id}`,
  )

  return {
    request: {
      ...request,
      id: data.verification_id,
      thid: data.verification_id,
      body: {
        ...request.body,
        scope: [CLAIM_TYPES_MAP_ON_CHAIN[claimType]],
      },
    },
    jwtToken: data.jwt,
  }
}

export const getJWZ = async (jwtToken: string, verificationId: string) => {
  const { data } = await api.get<{
    jwz: string
  }>(`/integrations/verify-proxy/v1/public/verify/response/${verificationId}`, {
    headers: {
      Authorization: `Bearer ${jwtToken}`,
    },
  })

  return data.jwz
}
```

After getting a JWZ from `getJWZ(...)` function, we can submit our proof to the on-chain contract using the following code:

```ts
/* ... */

const submitZkp = useCallback(async () => {
    setIsSubmitting(true)

    try {
        if (!jwzToken) throw new TypeError('ZKP is not defined')

        const zkProofPayload = JSON.parse(jwzToken.getPayload())

        const zkProof = zkProofPayload.body.scope[0] as ZKProof

        const txBody = getProveIdentityTxBody(
            '1',
            zkProof.pub_signals.map(el => BigInt(el)),
            [zkProof.proof.pi_a[0], zkProof.proof.pi_a[1]],
            [
            [zkProof.proof.pi_b[0][1], zkProof.proof.pi_b[0][0]],
            [zkProof.proof.pi_b[1][1], zkProof.proof.pi_b[1][0]],
            ],
            [zkProof.proof.pi_c[0], zkProof.proof.pi_c[1]],
        )

        const tx = await provider?.signAndSendTx?.({
            to: config?.[
                `QUERY_VERIFIER_CONTRACT_ADDRESS_${selectedChainToPublish}`
            ],
            ...txBody,
        })

        verificationSuccessTx.set((tx as EthTransactionResponse).transactionHash)

        navigate(RoutesPaths.authSuccess)
        } catch (error) {
        ErrorHandler.process(error)
        }

        setIsSubmitting(false)
    }, [
        getProveIdentityTxBody,
        jwzToken,
        navigate,
        provider,
        selectedChainToPublish,
        verificationSuccessTx,
    ])

/* ... */
```

It is enough to process the "proof flow" and mint an SBT for the user.
For the whole code example with the UI visit the [GitHub](https://github.com/rarimo/web-client-polygonid/tree/main).

