---
sidebar_label: 'Smart contracts reference'
description: 'Information about the smart contracts used in the Freedom Tool.'
---

import OutLink from "@site/src/components/OutLink";

# Freedom Tool: Smart contracts reference

## `VotingRegistry`

Responsible for managing pool implementations and instances.
Right now it supports following types:
- "Simple Voting": contract is `Voting`
- "Simple Registration": contract is `Registration`

### Deployments

| Chain   | ChainID    | Address                                                                                                                                       |
| ------- | ---------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
| Arbitrum | `42161` | `0x3053430564c22b2753bc63ccf37f166159d473d7` \(<OutLink href="https://arbiscan.io/address/0x3053430564c22b2753bc63ccf37f166159d473d7">Arbiscan</OutLink>\) |


### Interface

```solidity
contract VotingRegistry is IVotingRegistry, Initializable, OwnableUpgradeable, UUPSUpgradeable {
    address public poolFactory;
    mapping(address => string) private _typeByPool; 
    mapping(string => EnumerableSet.AddressSet) private _poolByType; 
    mapping(address => EnumerableSet.AddressSet) private _poolByAddress;
    mapping(address => mapping(string => EnumerableSet.AddressSet)) private _poolByAddressAndType;
    mapping(string => address) private _poolImplementations;
    mapping(address => mapping(address => address)) private _registrationToVoting;

    modifier onlyEqualLength(string[] memory poolType_, address[] memory newImplementations_) {
        _requireEqualLength(poolType_, newImplementations_);
        _;
    }

    modifier onlyFactory() {
        _requireOnlyFactory();
        _;
    }

    function setNewImplementations(
        string[] memory poolTypes_,
        address[] memory newImplementations_
    ) external onlyOwner onlyEqualLength(poolTypes_, newImplementations_) {
        for (uint256 i = 0; i < poolTypes_.length; i++) {
        _poolByAddressAndType[proposer_][poolType_].add(pool_);

        _typeByPool[pool_] = poolType_;
    }

    function bindVotingToRegistration(
        address proposer_,
        address voting_,
        address registration_
    ) external onlyFactory {
        require(
            bytes(_typeByPool[registration_]).length > 0,
            "VotingRegistry: registration pool not found"
        );

        require(
            _registrationToVoting[proposer_][registration_] == address(0),
            "VotingRegistry: registration pool already has a voting contract"
        );

        _registrationToVoting[proposer_][registration_] = voting_;
    }

    function _requireEqualLength(
        string[] memory names_,
        address[] memory newImplementations_
    ) private pure {
        require(
            names_.length == newImplementations_.length,
            "VotingRegistry: names and implementations length mismatch"
        );
    }

    function _requireOnlyFactory() private view {
        require(msg.sender == poolFactory, "VotingRegistry: only factory can call this function");
    }

```

- `poolFactory` — address of the `VotingFactory` contract;
- `_typeByPool` — mapping from pool address to poolType;
- `_poolByType` — mapping from poolType to pool;
- `_poolByAddress` — mapping from proposer to pool;
- `_poolByAddressAndType` — mapping from proposer to mapping from poolType to pool;
- `_poolImplementations` — mapping from poolType to poolImplementation;
- `_registrationToVoting` — mapping from proposer to mapping from registration to voting;
- `onlyEqualLength()` — modifier, that requires two input arrays to have the same length;
- `onlyFactory()` — modifier, that requires the `msg.sender` to be equal to `poolFactory`;
- `setNewImplementations()` — sets or upgrades the implementations for specified pool types. Only callable by the owner;
- `bindVotingToRegistration()` — Binds a voting contract to a registration contract. Only callable by the owner;
- `_requireEqualLength()` — private function, that implements the logic of `onlyEqualLength()` modifier;
- `_requireOnlyFactory()` — private function, that implements the logic of `onlyFactory()` modifier;

See <OutLink href="https://github.com/rarimo/voting-contracts/blob/main/contracts/core/VotingRegistry.sol">VotingRegistry.sol</OutLink> for the full implementation.

## `VotingFactory`

Responsible for creation of new voting and registration instances.

### Deployments

| Chain   | ChainID    | Address                                                                                                                                       |
| ------- | ---------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
| Arbitrum | `42161` | `0xed95bf009e4c7f8a8bc5ccf1ffb33be164b37cf8` \(<OutLink href="https://arbiscan.io/address/0xed95bf009e4c7f8a8bc5ccf1ffb33be164b37cf8">Arbiscan</OutLink>\) |


### Interface

```solidity
event InstanceCreated(
        string indexed instanceType,
        address indexed creator,
        address indexed voting
    );

/* ... */

contract VotingFactory is IVotingFactory, Initializable, UUPSUpgradeable {
    IVotingRegistry public votingRegistry;

    modifier onlyExistingPoolType(string memory votingType_) {
        _requireExistingPoolType(votingType_);
        _;
    }

    function createRegistration(string memory registrationType_, bytes memory data_) external {
        _createPool(registrationType_, data_);
    }

    function createRegistrationWithSalt(
        string memory registrationType_,
        bytes memory data_,
        bytes32 salt_
    ) external {
        _createPoolWithSalt(registrationType_, data_, salt_);
    }

    function createVoting(string memory votingType_, bytes memory data_) external {
        address voting_ = _createPool(votingType_, data_);

        require(
            ERC165Checker.supportsInterface(voting_, type(IVotingPool).interfaceId),
            "VotingFactory: voting pool does not support IVotingPool"
        );

        address[] memory registrations_ = IVotingPool(voting_).getRegistrationAddresses();

        for (uint256 i = 0; i < registrations_.length; i++) {
            votingRegistry.bindVotingToRegistration(msg.sender, voting_, registrations_[i]);
        }
    }

    function createVotingWithSalt(
        string memory votingType_,
        bytes memory data_,
        bytes32 salt_
    ) external {
        address voting_ = _createPoolWithSalt(votingType_, data_, salt_);

        require(
            ERC165Checker.supportsInterface(voting_, type(IVotingPool).interfaceId),
            "VotingFactory: voting pool does not support IVotingPool"
        );

        address[] memory registration_ = IVotingPool(voting_).getRegistrationAddresses();

        for (uint256 i = 0; i < registration_.length; i++) {
            votingRegistry.bindVotingToRegistration(msg.sender, voting_, registration_[i]);
        }
    }

    function predictAddress(
        string memory poolType_,
        address proposer_,
        bytes32 salt_
    ) external view returns (address) {
        bytes32 combinedSalt_ = keccak256(abi.encodePacked(proposer_, salt_));

        return _predictPoolAddress(poolType_, new bytes(0), combinedSalt_);
    }

    function _createPool(
        string memory poolType_,
        bytes memory data_
    ) internal onlyExistingPoolType(poolType_) returns (address) {
        address pool_ = _deploy(poolType_, data_);

        _register(poolType_, msg.sender, pool_);

        emit InstanceCreated(poolType_, msg.sender, pool_);

        return pool_;
    }

    function _createPoolWithSalt(
        string memory poolType_,
        bytes memory data_,
        bytes32 salt_
    ) internal onlyExistingPoolType(poolType_) returns (address) {
        bytes32 combinedSalt_ = keccak256(abi.encodePacked(msg.sender, salt_));

        address pool_ = _deploy2(poolType_, new bytes(0), combinedSalt_);

        (bool success_, bytes memory returnData_) = pool_.call(data_);
        Address.verifyCallResult(
            success_,
            returnData_,
            "VotingFactory: failed to initialize pool"
        );

        _register(poolType_, msg.sender, pool_);

        emit InstanceCreated(poolType_, msg.sender, pool_);

        return pool_;
    }

    function _deploy(string memory poolType_, bytes memory data_) private returns (address) {
        return address(new ERC1967Proxy(votingRegistry.getPoolImplementation(poolType_), data_));
    }

    function _deploy2(
        string memory poolType_,
        bytes memory data_,
        bytes32 salt_
    ) private returns (address) {
        return
            address(
                new ERC1967Proxy{salt: salt_}(
                    votingRegistry.getPoolImplementation(poolType_),
                    data_
                )
            );
    }

    function _register(string memory poolType_, address proposer_, address poolProxy_) private {
        votingRegistry.addProxyPool(poolType_, proposer_, poolProxy_);
    }

    function _predictPoolAddress(
        string memory poolType_,
        bytes memory data_,
        bytes32 salt_
    ) private view returns (address) {
        bytes32 bytecodeHash = keccak256(
            abi.encodePacked(
                type(ERC1967Proxy).creationCode,
                abi.encode(votingRegistry.getPoolImplementation(poolType_), data_)
            )
        );

        return Create2.computeAddress(salt_, bytecodeHash);
    }

    function _requireExistingPoolType(string memory poolType_) private view {
        require(
            votingRegistry.getPoolImplementation(poolType_) != address(0),
            "VotingFactory: pool type does not exist"
        );
    }
}
```

- `InstanceCreated` — event, that is emitted when a new instance is created. Contains:
    - `instanceType` — the type of the instance;
    - `creator` — creator address;
    - `voting` — address of the newly created instance;
- `onlyExistingPoolType()` — modifier, that requires the poolType to exist in the `votingRegistry`;
- `createRegistration()` — creates a new registration instance with specified parameters;
- `createRegistrationWithSalt()` — creates a new registration instance deterministically with specified parameters and a salt;
- `createVoting()` — creates a new voting instance with specified parameters;
- `createVotingWithSalt()` — creates a new voting instance deterministically with specified parameters and salt;
- `predictAddress()` — predicts the address of an instance that would be deployed with the given parameters and salt;
- `_requireExistingPoolType()` — private function, that implements the logic of `onlyExistingPoolType` modifier;

See <OutLink href="https://github.com/rarimo/voting-contracts/blob/main/contracts/core/VotingFactory.sol">VotingFactory.sol</OutLink> for the full implementation.

## `Registration`

Implementation of a registration system with ZKPs for privacy and integrity, and a Merkle tree for registration tracking.

### Deployments

| Chain   | ChainID    | Address                                                                                                                                       |
| ------- | ---------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
| Arbitrum | `42161` | `0x1cd9be5BBD91c07aA31180834e48cf4838992317` \(<OutLink href="https://arbiscan.io/address/0x1cd9be5BBD91c07aA31180834e48cf4838992317">Arbiscan</OutLink>\) |


### Interface

```solidity
event UserRegistered(
    address indexed user,
    IBaseVerifier.ProveIdentityParams proveIdentityParams,
    IRegisterVerifier.RegisterProofParams registerProofParams
);

/* ... */

contract Registration is IRegistration, PoseidonSMT, Initializable {
    IRegisterVerifier public immutable registerVerifier; 
    uint256 public immutable smtTreeMaxDepth; 
    RegistrationInfo public registrationInfo; 
    mapping(bytes32 => bool) public commitments; 
    mapping(bytes32 => bool) public rootsHistory;

    function register(
        IBaseVerifier.ProveIdentityParams memory proveIdentityParams_,
        IRegisterVerifier.RegisterProofParams memory registerProofParams_,
        IBaseVerifier.TransitStateParams memory transitStateParams_,
        bool isTransitState_
    ) external {
        require(
            getRegistrationStatus() == RegistrationStatus.COMMITMENT,
            "Registration: the registration must be in the commitment state"
        );

        bytes32 commitment_ = registerProofParams_.commitment;

        require(!commitments[commitment_], "Registration: commitment already exists");

        IRegisterVerifier.RegisterProofInfo memory registerProofInfo_ = IRegisterVerifier
            .RegisterProofInfo({
                registerProofParams: registerProofParams_,
                registrationContractAddress: address(this)
            });

        if (isTransitState_) {
            registerVerifier.transitStateAndProveRegistration(
                proveIdentityParams_,
                registerProofInfo_,
                transitStateParams_
            );
        } else {
            registerVerifier.proveRegistration(proveIdentityParams_, registerProofInfo_);
        }

        _add(commitment_);
        commitments[commitment_] = true;
        rootsHistory[getRoot()] = true;
        registrationInfo.counters.totalRegistrations++;

        emit UserRegistered(msg.sender, proveIdentityParams_, registerProofParams_);
    }
}
```

- `UserRegistered` — event, that is emitted when a user successfully registers. Contains:
    - `user` — address of the user registering;
    - `proveIdentityParams` — parameters used for proving the user's identity;
    - `registerProofParams` — parameters used for the registration proof;
- `registerVerifier` — contract for registration proof verification;
- `smtTreeMaxDepth` — the maximum depth of the Sparse Merkle Tree (SMT);
- `registrationInfo` — struct containing all relevant registration information;
- `commitments` — mapping to track commitments and prevent duplicate registrations;
- `rootsHistory` — mapping to track roots and validate their existence;
- `register()` — registers a user, verifying his identity and registration proof;

See <OutLink href="https://github.com/rarimo/voting-contracts/blob/main/contracts/core/Registration.sol">Registration.sol</OutLink> for the full implementation.

## `Voting`

Implementation of a voting system with registration and voting phases, utilizing ZKPs for privacy and integrity, and a Merkle tree for vote tracking.

### Deployments

| Chain   | ChainID    | Address                                                                                                                                       |
| ------- | ---------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
| Arbitrum | `42161` | `0x933284F0E1D76C5cA49f72eD38cc36Dd39b38704` \(<OutLink href="https://arbiscan.io/address/0x933284F0E1D76C5cA49f72eD38cc36Dd39b38704">Arbiscan</OutLink>\) |


### Interface

```solidity
event UserVoted(
    address indexed user, 
    bytes32 root, 
    bytes32 nullifierHash, 
    bytes32 candidate
    );

/* ... */ 

contract Voting is IVoting, ERC165, Initializable {
    uint256 public constant MAX_CANDIDATES = 100;
    address public immutable voteVerifier; 
    IRegistration public registration; 
    VotingInfo public votingInfo; 
    mapping(bytes32 => bool) public nullifiers; 
    mapping(bytes32 => bool) public candidates; 
    mapping(bytes32 => uint256) public votesPerCandidate; 

    function vote(
        bytes32 root_,
        bytes32 nullifierHash_,
        bytes32 candidate_,
        VerifierHelper.ProofPoints memory proof_
    ) external {
        require(
            getProposalStatus() == VotingStatus.PENDING,
            "Voting: the voting must be in the pending state to vote"
        );

        require(!nullifiers[nullifierHash_], "Voting: nullifier already used");
        require(registration.isRootExists(root_), "Voting: root doesn't exist");
        require(candidates[candidate_], "Voting: candidate doesn't exist");

        require(
            voteVerifier.verifyProofSafe(
                [
                    uint256(nullifierHash_),
                    uint256(root_),
                    uint256(candidate_),
                    uint256(uint160(address(this)))
                ].asDynamic(),
                proof_,
                4
            ),
            "Voting: Invalid vote proof"
        );

        nullifiers[nullifierHash_] = true;

        votesPerCandidate[candidate_]++;
        votingInfo.counters.votesCount++;

        emit UserVoted(msg.sender, root_, nullifierHash_, candidate_);
    }

    function _validateVotingParams(VotingParams calldata votingParams_) internal view {
        require(
            votingParams_.votingStart > block.timestamp,
            "Voting: voting start must be in the future"
        );
        require(
            address(votingParams_.registration) != address(0),
            "Voting: registration contract must be provided"
        );
        require(votingParams_.votingPeriod > 0, "Voting: voting period must be greater than 0");
        require(votingParams_.candidates.length > 0, "Voting: candidates must be provided");
        require(votingParams_.candidates.length <= MAX_CANDIDATES, "Voting: too many candidates");

        IRegistration.RegistrationInfo memory registrationInfo = registration
            .getRegistrationInfo();
        require(
            registrationInfo.values.commitmentEndTime < votingParams_.votingStart,
            "Voting: voting start must be after registration end"
        );
    }
}
```

- `UserVoted` — event, that is emitted when user casts a vote. Contains:
    - `user` — address of the user voting;
    - `root` — root of the SMT that was used at the time of voting;
    - `nullifierHash` — hash of the nullifier to prevent double voting;
    - `candidate` —  identifier of the candidate who was voted for;
- `MAX_CANDIDATES` — maximum number of candidates in a pool;
- `voteVerifier` — contract for voting proof verification;
- `registration` — contract for validation of registration;
- `votingInfo` — struct containing all relevant voting information;
- `nullifiers` — mapping to track nullifiers and prevent double voting;
- `candidates` — mapping of candidates available for voting;
- `votesPerCandidate` — mapping to track votes per candidate;
- `vote()` — allows a registered user to cast a vote for a candidate;
- `_validateVotingParams()` — performs the validation of provided parameters;

See <OutLink href="https://github.com/rarimo/voting-contracts/blob/main/contracts/core/Voting.sol">Voting.sol</OutLink> for the full implementation.
