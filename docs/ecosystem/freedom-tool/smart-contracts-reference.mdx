---
sidebar_label: 'Smart contracts reference'
description: 'Listing of smart contracts used by the Freedom Tool.'
---

import OutLink from "@site/src/components/OutLink";

# Freedom Tool: Smart contracts reference

## `VotingRegistry`

Responsible for managing voting pools.
It handles the `Voting` and `Registration` instances.

### Deployments

| Chain   | ChainID    | Address                                                                                                                                       |
| ------- | ---------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
| Arbitrum | `42161` | `0x1d84cFd4839fE92dAe8E1F8F777010c08a60013C` \(<OutLink href="https://arbiscan.io/address/0x1d84cFd4839fE92dAe8E1F8F777010c08a60013C">Arbiscan</OutLink>\) |


### Interface

```solidity title="/contracts/core/VotingRegistry.sol"
contract VotingRegistry is IVotingRegistry, Initializable, OwnableUpgradeable, UUPSUpgradeable {
    address public poolFactory;
    mapping(address => string) private _typeByPool;
    mapping(string => EnumerableSet.AddressSet) private _poolByType;
    mapping(address => EnumerableSet.AddressSet) private _poolByAddress;
    mapping(address => mapping(string => EnumerableSet.AddressSet)) private _poolByAddressAndType;
    mapping(string => address) private _poolImplementations;
    mapping(address => mapping(address => address)) private _registrationToVoting;

    modifier onlyEqualLength(string[] memory poolType_, address[] memory newImplementations_) {
        _requireEqualLength(poolType_, newImplementations_);
        _;
    }

    modifier onlyFactory() {
        _requireOnlyFactory();
        _;
    }

    function setNewImplementations(
        string[] memory poolTypes_,
        address[] memory newImplementations_
    ) external onlyOwner onlyEqualLength(poolTypes_, newImplementations_) {
        for (uint256 i = 0; i < poolTypes_.length; i++) {
        _poolByAddressAndType[proposer_][poolType_].add(pool_);

        _typeByPool[pool_] = poolType_;
    }

    function bindVotingToRegistration(
        address proposer_,
        address voting_,
        address registration_
    ) external onlyFactory {
        require(
            bytes(_typeByPool[registration_]).length > 0,
            "VotingRegistry: registration pool not found"
        );

        require(
            _registrationToVoting[proposer_][registration_] == address(0),
            "VotingRegistry: registration pool already has a voting contract"
        );

        _registrationToVoting[proposer_][registration_] = voting_;
    }

    function _requireEqualLength(
        string[] memory names_,
        address[] memory newImplementations_
    ) private pure {
        require(
            names_.length == newImplementations_.length,
            "VotingRegistry: names and implementations length mismatch"
        );
    }

    function _requireOnlyFactory() private view {
        require(msg.sender == poolFactory, "VotingRegistry: only factory can call this function");
    }

```

- `poolFactory` — address of the `VotingFactory` contract;
- `_typeByPool` — mapping from pool address to poolType;
- `_poolByType` — mapping from poolType to pool;
- `_poolByAddress` — mapping from proposer to pool;
- `_poolByAddressAndType` — mapping from proposer to mapping from poolType to pool;
- `_poolImplementations` — mapping from poolType to poolImplementation;
- `_registrationToVoting` — mapping from proposer to mapping from registration to voting;
- `onlyEqualLength()` — modifier that requires two input arrays to have the same length;
- `onlyFactory()` — modifier that requires the `msg.sender` to be equal to `poolFactory`;
- `setNewImplementations()` — sets or upgrades the implementations for specified pool types. Only callable by the owner;
- `bindVotingToRegistration()` — Binds a voting contract to a registration contract. Only callable by the owner;
- `_requireEqualLength()` — private function that implements the logic of `onlyEqualLength()` modifier;
- `_requireOnlyFactory()` — private function that implements the logic of `onlyFactory()` modifier;

See <OutLink href="https://github.com/rarimo/voting-contracts/blob/main/contracts/core/VotingRegistry.sol">VotingRegistry.sol</OutLink> for the full implementation.

## `VotingFactory`

Responsible for the creation of new voting and registration instances.

### Deployments

| Chain   | ChainID    | Address                                                                                                                                       |
| ------- | ---------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
| Arbitrum | `42161` | `0x43E547aCE25b91d2cb00D96BE6b10f34f36A6B7F` \(<OutLink href="https://arbiscan.io/address/0x43E547aCE25b91d2cb00D96BE6b10f34f36A6B7F">Arbiscan</OutLink>\) |


### Interface

```solidity title="/contracts/core/VotingFactory.sol"
event InstanceCreated(
        string indexed instanceType,
        address indexed creator,
        address indexed voting
    );

/* ... */

contract VotingFactory is IVotingFactory, Initializable, UUPSUpgradeable {
    IVotingRegistry public votingRegistry;

    modifier onlyExistingPoolType(string memory votingType_) {
        _requireExistingPoolType(votingType_);
        _;
    }

    function createRegistration(string memory registrationType_, bytes memory data_) external {
        _createPool(registrationType_, data_);
    }

    function createRegistrationWithSalt(
        string memory registrationType_,
        bytes memory data_,
        bytes32 salt_
    ) external {
        _createPoolWithSalt(registrationType_, data_, salt_);
    }

    function createVoting(string memory votingType_, bytes memory data_) external {
        address voting_ = _createPool(votingType_, data_);

        require(
            ERC165Checker.supportsInterface(voting_, type(IVotingPool).interfaceId),
            "VotingFactory: voting pool does not support IVotingPool"
        );

        address[] memory registrations_ = IVotingPool(voting_).getRegistrationAddresses();

        for (uint256 i = 0; i < registrations_.length; i++) {
            votingRegistry.bindVotingToRegistration(msg.sender, voting_, registrations_[i]);
        }
    }

    function createVotingWithSalt(
        string memory votingType_,
        bytes memory data_,
        bytes32 salt_
    ) external {
        address voting_ = _createPoolWithSalt(votingType_, data_, salt_);

        require(
            ERC165Checker.supportsInterface(voting_, type(IVotingPool).interfaceId),
            "VotingFactory: voting pool does not support IVotingPool"
        );

        address[] memory registration_ = IVotingPool(voting_).getRegistrationAddresses();

        for (uint256 i = 0; i < registration_.length; i++) {
            votingRegistry.bindVotingToRegistration(msg.sender, voting_, registration_[i]);
        }
    }

    function predictAddress(
        string memory poolType_,
        address proposer_,
        bytes32 salt_
    ) external view returns (address) {
        bytes32 combinedSalt_ = keccak256(abi.encodePacked(proposer_, salt_));

        return _predictPoolAddress(poolType_, new bytes(0), combinedSalt_);
    }

    function _createPool(
        string memory poolType_,
        bytes memory data_
    ) internal onlyExistingPoolType(poolType_) returns (address) {
        address pool_ = _deploy(poolType_, data_);

        _register(poolType_, msg.sender, pool_);

        emit InstanceCreated(poolType_, msg.sender, pool_);

        return pool_;
    }

    function _createPoolWithSalt(
        string memory poolType_,
        bytes memory data_,
        bytes32 salt_
    ) internal onlyExistingPoolType(poolType_) returns (address) {
        bytes32 combinedSalt_ = keccak256(abi.encodePacked(msg.sender, salt_));

        address pool_ = _deploy2(poolType_, new bytes(0), combinedSalt_);

        (bool success_, bytes memory returnData_) = pool_.call(data_);
        Address.verifyCallResult(
            success_,
            returnData_,
            "VotingFactory: failed to initialize pool"
        );

        _register(poolType_, msg.sender, pool_);

        emit InstanceCreated(poolType_, msg.sender, pool_);

        return pool_;
    }

    function _deploy(string memory poolType_, bytes memory data_) private returns (address) {
        return address(new ERC1967Proxy(votingRegistry.getPoolImplementation(poolType_), data_));
    }

    function _deploy2(
        string memory poolType_,
        bytes memory data_,
        bytes32 salt_
    ) private returns (address) {
        return
            address(
                new ERC1967Proxy{salt: salt_}(
                    votingRegistry.getPoolImplementation(poolType_),
                    data_
                )
            );
    }

    function _register(string memory poolType_, address proposer_, address poolProxy_) private {
        votingRegistry.addProxyPool(poolType_, proposer_, poolProxy_);
    }

    function _predictPoolAddress(
        string memory poolType_,
        bytes memory data_,
        bytes32 salt_
    ) private view returns (address) {
        bytes32 bytecodeHash = keccak256(
            abi.encodePacked(
                type(ERC1967Proxy).creationCode,
                abi.encode(votingRegistry.getPoolImplementation(poolType_), data_)
            )
        );

        return Create2.computeAddress(salt_, bytecodeHash);
    }

    function _requireExistingPoolType(string memory poolType_) private view {
        require(
            votingRegistry.getPoolImplementation(poolType_) != address(0),
            "VotingFactory: pool type does not exist"
        );
    }
}
```

- `InstanceCreated` — an event emitted when a new instance is created. Contains:
    - `instanceType` — the type of the instance;
    - `creator` — creator address;
    - `voting` — address of the newly created instance;
- `onlyExistingPoolType()` — modifier that requires the poolType to exist in the `votingRegistry`;
- `createRegistration()` — creates a new registration instance with specified parameters;
- `createRegistrationWithSalt()` — creates a new registration instance deterministically with specified parameters and a salt;
- `createVoting()` — creates a new voting instance with specified parameters;
- `createVotingWithSalt()` — creates a new voting instance deterministically with specified parameters and salt;
- `predictAddress()` — predicts the address of an instance that will be deployed with the given parameters and salt;
- `_requireExistingPoolType()` — private function that implements the logic of `onlyExistingPoolType` modifier;

See <OutLink href="https://github.com/rarimo/voting-contracts/blob/main/contracts/core/VotingFactory.sol">VotingFactory.sol</OutLink> for the full implementation.

## `RegisterVerifier`

It is a modified Iden3 contract that verifies ZKP and checks the uniqueness of the applicants.

<!-- TODO: Add arbitrum contracts addresses -->

### Interface

```solidity title="/contracts/iden3/verifiers/RegisterVerifier.sol"
event RegisterAccepted(
    uint256 documentNullifier,
    RegisterProofInfo registerProofInfo
    );

/* ... */

contract RegisterVerifier is IRegisterVerifier, BaseVerifier {
    string public constant REGISTER_PROOF_QUERY_ID = "REGISTER_PROOF";

    EnumerableSet.UintSet internal _issuingAuthorityWhitelist;
    EnumerableSet.UintSet internal _issuingAuthorityBlacklist;
    mapping(address => mapping(uint256 => RegisterProofInfo)) private _registrationProofInfo;

    modifier onlyRegistrationContract(RegisterProofInfo memory registerProofInfo_) {
        _onlyRegistrationContract(registerProofInfo_);
        _;
    }

    function proveRegistration(
        ProveIdentityParams memory proveIdentityParams_,
        RegisterProofInfo memory registerProofInfo_
    ) external onlyRegistrationContract(registerProofInfo_) {
        _proveRegistration(proveIdentityParams_, registerProofInfo_);
    }

    function transitStateAndProveRegistration(
        ProveIdentityParams memory proveIdentityParams_,
        RegisterProofInfo memory registerProofInfo_,
        TransitStateParams memory transitStateParams_
    ) external onlyRegistrationContract(registerProofInfo_) {
        _transitState(transitStateParams_);
        _proveRegistration(proveIdentityParams_, registerProofInfo_);
    }

    function _proveRegistration(
        ProveIdentityParams memory proveIdentityParams_,
        RegisterProofInfo memory registerProofInfo_
    ) internal {
        _verify(REGISTER_PROOF_QUERY_ID, proveIdentityParams_, registerProofInfo_);

        address registrationContract_ = registerProofInfo_.registrationContractAddress;
        uint256 documentNullifier_ = registerProofInfo_.registerProofParams.documentNullifier;

        require(
            !isIdentityRegistered(registrationContract_, documentNullifier_),
            "RegisterVerifier: Identity is already registered."
        );

        _registrationProofInfo[registrationContract_][documentNullifier_] = registerProofInfo_;

        emit RegisterAccepted(documentNullifier_, registerProofInfo_);
    }

    function _verify(
        string memory queryId_,
        ProveIdentityParams memory proveIdentityParams_,
        RegisterProofInfo memory registerProofInfo_
    ) internal view {
        require(
            zkpQueriesStorage.isQueryExists(queryId_),
            "RegisterVerifier: ZKP Query does not exist for passed query id."
        );

        IQueryMTPValidator queryValidator_ = IQueryMTPValidator(
            zkpQueriesStorage.getQueryValidator(queryId_)
        );

        IZKPQueriesStorage.CircuitQuery memory circuitQuery_ = zkpQueriesStorage
            .getStoredCircuitQuery(queryId_);

        uint256[] memory values_ = new uint256[](1);
        values_[0] = PoseidonUnit3L.poseidon(
            [
                1, // Is Adult should be always 1
                registerProofInfo_.registerProofParams.issuingAuthority,
                registerProofInfo_.registerProofParams.documentNullifier
            ]
        );

        circuitQuery_.values = values_;

        uint256 queryHash_ = zkpQueriesStorage.getQueryHash(circuitQuery_);

        _validateRegistrationFields(
            queryValidator_,
            proveIdentityParams_.inputs,
            registerProofInfo_
        );

        queryValidator_.verify(
            proveIdentityParams_.statesMerkleData,
            proveIdentityParams_.inputs,
            proveIdentityParams_.a,
            proveIdentityParams_.b,
            proveIdentityParams_.c,
            queryHash_
        );

        _checkAllowedIssuer(queryId_, proveIdentityParams_.statesMerkleData.issuerId);
    }

    function _onlyRegistrationContract(RegisterProofInfo memory registerProofInfo_) private view {
        require(
            msg.sender == registerProofInfo_.registrationContractAddress,
            "RegisterVerifier: the caller is not the voting contract."
        );
    }

    function _validateRegistrationFields(
        IQueryMTPValidator queryValidator_,
        uint256[] memory inputs_,
        RegisterProofInfo memory registerProofInfo_
    ) private view {
        uint256 issuingAuthority_ = registerProofInfo_.registerProofParams.issuingAuthority;

        require(
            !isIssuingAuthorityBlacklisted(issuingAuthority_),
            "RegisterVerifier: Issuing authority is blacklisted."
        );

        require(
            _issuingAuthorityWhitelist.length() == 0 ||
                isIssuingAuthorityWhitelisted(issuingAuthority_),
            "RegisterVerifier: Issuing authority is not whitelisted."
        );

        uint256 commitmentIndex_ = queryValidator_.getCommitmentIndex();
        uint256 registrationAddressIndex_ = queryValidator_.getRegistrationAddressIndex();

        require(
            bytes32(inputs_[commitmentIndex_]) ==
                registerProofInfo_.registerProofParams.commitment,
            "RegisterVerifier: commitment does not match the requested one."
        );

        require(inputs_[commitmentIndex_] != 0, "RegisterVerifier: commitment should not be zero");

        require(
            inputs_[registrationAddressIndex_] ==
                uint256(uint160(registerProofInfo_.registrationContractAddress)),
            "RegisterVerifier: registration address does not match the requested one."
        );
    }
}
```

- `RegisterAccepted` — event that is emitted when registration is accepted. Contains:
    - `documentNullifier` — unique nullifier for the document;
    - `registerProofInfo` — information regarding the registration proof;
- `REGISTER_PROOF_QUERY_ID` — unique query identifier. Used as a public parameter in ZKP;
- `_issuingAuthorityWhitelist` — a whitelist of issuing authorities;
- `_issuingAuthorityBlacklist` — a blacklist of issuing authorities;
- `_registrationProofInfo` — mapping from registration contract address to mapping from documentNullifier to RegisterProofInfo;
- `onlyRegistrationContract()` — modifier that requires the caller to be equal to the registration contract address;
- `proveRegistration()` — proves registration with given parameters;
- `transitStateAndProveRegistration()` — transits the state and proves registration with given parameters;
- `_verify()` — verifies the ZKP;
- `_onlyRegistrationContract()` — private function that implements the logic of the `onlyRegistrationContract()` modifier;
- `_validateRegistrationFields()` — performs the validation of fields (whitelisted/blacklisted/commitments equivalence, etc);

See <OutLink href="https://github.com/rarimo/voting-contracts/blob/main/contracts/iden3/verifiers/RegisterVerifier.sol">RegisterVerifier.sol</OutLink> for the full implementation.

## `Registration`

This contract contracts checks the ZK eligibility proofs and keeps track of all the participants.

### Deployments

| Chain   | ChainID    | Address                                                                                                                                       |
| ------- | ---------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
| Arbitrum | `42161` | `0x1cd9be5BBD91c07aA31180834e48cf4838992317` \(<OutLink href="https://arbiscan.io/address/0x1cd9be5BBD91c07aA31180834e48cf4838992317">Arbiscan</OutLink>\) |


### Interface

```solidity title="/contracts/core/Registration.sol"
event UserRegistered(
    address indexed user,
    IBaseVerifier.ProveIdentityParams proveIdentityParams,
    IRegisterVerifier.RegisterProofParams registerProofParams
);

/* ... */

contract Registration is IRegistration, PoseidonSMT, Initializable {
    IRegisterVerifier public immutable registerVerifier;
    uint256 public immutable smtTreeMaxDepth;
    RegistrationInfo public registrationInfo;
    mapping(bytes32 => bool) public commitments;
    mapping(bytes32 => bool) public rootsHistory;

    function register(
        IBaseVerifier.ProveIdentityParams memory proveIdentityParams_,
        IRegisterVerifier.RegisterProofParams memory registerProofParams_,
        IBaseVerifier.TransitStateParams memory transitStateParams_,
        bool isTransitState_
    ) external {
        require(
            getRegistrationStatus() == RegistrationStatus.COMMITMENT,
            "Registration: the registration must be in the commitment state"
        );

        bytes32 commitment_ = registerProofParams_.commitment;

        require(!commitments[commitment_], "Registration: commitment already exists");

        IRegisterVerifier.RegisterProofInfo memory registerProofInfo_ = IRegisterVerifier
            .RegisterProofInfo({
                registerProofParams: registerProofParams_,
                registrationContractAddress: address(this)
            });

        if (isTransitState_) {
            registerVerifier.transitStateAndProveRegistration(
                proveIdentityParams_,
                registerProofInfo_,
                transitStateParams_
            );
        } else {
            registerVerifier.proveRegistration(proveIdentityParams_, registerProofInfo_);
        }

        _add(commitment_);
        commitments[commitment_] = true;
        rootsHistory[getRoot()] = true;
        registrationInfo.counters.totalRegistrations++;

        emit UserRegistered(msg.sender, proveIdentityParams_, registerProofParams_);
    }
}
```

- `UserRegistered` — an event emitted when a user successfully registers. Contains:
    - `user` — address of the user registering;
    - `proveIdentityParams` — parameters used for proving the user's identity;
    - `registerProofParams` — parameters used for the registration proof;
- `registerVerifier` — contract for registration proof verification;
- `smtTreeMaxDepth` — the maximum depth of the Sparse Merkle Tree (SMT);
- `registrationInfo` — struct containing all relevant registration information;
- `commitments` — mapping to track commitments and prevent duplicate registrations;
- `rootsHistory` — mapping to track roots and validate their existence;
- `register()` — registers a user, verifying his identity and proof of registration. Checks that the user is unique and hasn't been previously registered (through `RegisterVerifier` call);

See <OutLink href="https://github.com/rarimo/voting-contracts/blob/main/contracts/core/Registration.sol">Registration.sol</OutLink> for the full implementation.

## `Voting`

Implementation of a voting system with registration and voting phases, utilizing ZKPs for privacy and integrity, and a Merkle tree for vote tracking.

### Deployments

| Chain   | ChainID    | Address                                                                                                                                       |
| ------- | ---------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
| Arbitrum | `42161` | `0x933284F0E1D76C5cA49f72eD38cc36Dd39b38704` \(<OutLink href="https://arbiscan.io/address/0x933284F0E1D76C5cA49f72eD38cc36Dd39b38704">Arbiscan</OutLink>\) |


### Interface

```solidity title="/contracts/core/Voting.sol"
event UserVoted(
    address indexed user,
    bytes32 root,
    bytes32 nullifierHash,
    bytes32 candidate
    );

/* ... */

contract Voting is IVoting, ERC165, Initializable {
    uint256 public constant MAX_CANDIDATES = 100;
    address public immutable voteVerifier;
    IRegistration public registration;
    VotingInfo public votingInfo;
    mapping(bytes32 => bool) public nullifiers;
    mapping(bytes32 => bool) public candidates;
    mapping(bytes32 => uint256) public votesPerCandidate;

    function vote(
        bytes32 root_,
        bytes32 nullifierHash_,
        bytes32 candidate_,
        VerifierHelper.ProofPoints memory proof_
    ) external {
        require(
            getProposalStatus() == VotingStatus.PENDING,
            "Voting: the voting must be in the pending state to vote"
        );

        require(!nullifiers[nullifierHash_], "Voting: nullifier already used");
        require(registration.isRootExists(root_), "Voting: root doesn't exist");
        require(candidates[candidate_], "Voting: candidate doesn't exist");

        require(
            voteVerifier.verifyProofSafe(
                [
                    uint256(nullifierHash_),
                    uint256(root_),
                    uint256(candidate_),
                    uint256(uint160(address(this)))
                ].asDynamic(),
                proof_,
                4
            ),
            "Voting: Invalid vote proof"
        );

        nullifiers[nullifierHash_] = true;

        votesPerCandidate[candidate_]++;
        votingInfo.counters.votesCount++;

        emit UserVoted(msg.sender, root_, nullifierHash_, candidate_);
    }

    function _validateVotingParams(VotingParams calldata votingParams_) internal view {
        require(
            votingParams_.votingStart > block.timestamp,
            "Voting: voting start must be in the future"
        );
        require(
            address(votingParams_.registration) != address(0),
            "Voting: registration contract must be provided"
        );
        require(votingParams_.votingPeriod > 0, "Voting: voting period must be greater than 0");
        require(votingParams_.candidates.length > 0, "Voting: candidates must be provided");
        require(votingParams_.candidates.length <= MAX_CANDIDATES, "Voting: too many candidates");

        IRegistration.RegistrationInfo memory registrationInfo = registration
            .getRegistrationInfo();
        require(
            registrationInfo.values.commitmentEndTime < votingParams_.votingStart,
            "Voting: voting start must be after registration end"
        );
    }
}
```

- `UserVoted` — event that is emitted when the user casts a vote. Contains:
    - `user` — address of the user voting;
    - `root` — the root of the SMT that was used at the time of voting;
    - `nullifierHash` — hash of the nullifier to prevent double voting;
    - `candidate` —  identifier of the candidate who was voted for;
- `MAX_CANDIDATES` — maximum number of candidates in a pool;
- `voteVerifier` — contract for voting proof verification;
- `registration` — contract for validation of registration;
- `votingInfo` — struct containing all relevant voting information;
- `nullifiers` — mapping to track nullifiers and prevent double voting;
- `candidates` — mapping of candidates available for voting;
- `votesPerCandidate` — mapping to track votes per candidate;
- `vote()` — allows a registered user to cast a vote for a candidate;
- `_validateVotingParams()` — performs the validation of provided parameters;

See <OutLink href="https://github.com/rarimo/voting-contracts/blob/main/contracts/core/Voting.sol">Voting.sol</OutLink> for the full implementation.
